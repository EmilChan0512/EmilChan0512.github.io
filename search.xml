<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>杂感</title>
    <url>/2024/01/23/diary0123/</url>
    <content><![CDATA[<p>
    没有想到莆田的冬天竟这么冷。
    大抵是南京呆久了。室内的暖气给了我一种错觉，以为莆田的冬天也不会太冷。直到我裹成粽子在房间里码字。
    以至于感冒了。三天也不见好。现在脑袋昏昏沉沉，前端的学习也停滞了。话说回来，前端与游戏客户端到底走那条路，我还不甚明晰。
    身体快快好起来吧。还有很多要做的事情。
</p>
<div>
    <p>
    再学下去可能真的会晕，歇。看看unity吧。
    </p>
</div>]]></content>
  </entry>
  <entry>
    <title>first publish</title>
    <url>/2024/01/22/first-publish/</url>
    <content><![CDATA[<p><strong>my first pub</strong><br>let’s do something awsome</p>
<p>也许是中文的原因</p>
<p>再改改</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/01/22/hello-world/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>note-css-1</title>
    <url>/2024/01/23/note-css-1/</url>
    <content><![CDATA[<p>感觉塞一堆不好看，再起一个页面。</p>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p>有一个boarder画三角形的奇技淫巧</p>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><p>行内元素和块级元素的区别：（非常重要）</p>
<h3 id="行内元素："><a href="#行内元素：" class="headerlink" title="行内元素："></a>行内元素：</h3><p>与其他行内元素并排；<br>不能设置宽、高。默认的宽度，就是文字的宽度。</p>
<h3 id="块级元素："><a href="#块级元素：" class="headerlink" title="块级元素："></a>块级元素：</h3><p>霸占一行，不能与其他任何元素并列；<br>能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。</p>
<h3 id="行内元素和块级元素的分类："><a href="#行内元素和块级元素的分类：" class="headerlink" title="行内元素和块级元素的分类："></a>行内元素和块级元素的分类：</h3><p>在以前的HTML知识中，我们已经将标签分过类，当时分为了：文本级、容器级。</p>
<p>从HTML的角度来讲，标签分为：</p>
<p><strong>文本级标签：p、span、a、b、i、u、em。</strong><br><strong>容器级标签：div、h系列、li、dt、dd。</strong><br>PS：为甚么说p是文本级标签呢？因为p里面只能放文字&amp;图片&amp;表单元素，p里面不能放h和ul，p里面也不能放p。</p>
<p>现在，从CSS的角度讲，CSS的分类和上面的很像，就p不一样：</p>
<p><strong>行内元素：除了p之外，所有的文本级标签，都是行内元素。p是个文本级，但是是个块级元素。</strong></p>
<h3 id="定位属性"><a href="#定位属性" class="headerlink" title="定位属性"></a>定位属性</h3><p>z-index属性</p>
<p>（4）只有定位了的元素，才能有z-index值。也就是说，不管相对定位、绝对定位、固定定位，都可以使用z-index值。而浮动的元素不能用。</p>
<p>（5）从父现象：父亲怂了，儿子再牛逼也没用。意思是，如果父亲1比父亲2大，那么，即使儿子1比儿子2小，儿子1也能在最上层。</p>
<h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>属性选择器<br>结构伪类选择器<br><img src="/pic/image-shuxingxuanzeqi.png" alt="Alt text"></p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="盒子阴影"><a href="#盒子阴影" class="headerlink" title="盒子阴影"></a>盒子阴影</h4><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p>默认是content-box，即盒子的宽度 &#x3D; 内容的宽度(自己设置的) + padding + border<br>border-box，盒子的宽度就是自己设置的啦。设置的width就是总宽</p>
<h4 id="私有前缀"><a href="#私有前缀" class="headerlink" title="私有前缀"></a>私有前缀</h4><p>-webkit-  -moz-  -ms-  -o-<br>写gradient的时候；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">background: -webkit-linear-gradient(left, green, yellow);</span><br><span class="line">background: -moz-linear-gradient(left, green, yellow);</span><br><span class="line">background: -ms-linear-gradient(left, green, yellow);</span><br><span class="line">background: -o-linear-gradient(left, green, yellow);</span><br><span class="line">background: linear-gradient(left, green, yellow);</span><br></pre></td></tr></table></figure>
<h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><ul>
<li>圆角<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-top-left-radius</span>: <span class="number">60px</span> <span class="number">120px</span>;        //参数解释：水平半径   垂直半径</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-top-right-radius</span>: <span class="number">60px</span> <span class="number">120px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom-left-radius</span>: <span class="number">60px</span> <span class="number">120px</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border-bottom-right-radius</span>: <span class="number">60px</span> <span class="number">120px</span>;</span><br></pre></td></tr></table></figure></li>
<li>阴影<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: 水平偏移 垂直偏移 模糊程度 阴影大小 阴影颜色</span><br><span class="line"></span><br><span class="line">box-shadow: <span class="number">15px</span> <span class="number">21px</span> <span class="number">48px</span> -<span class="number">2px</span> <span class="number">#666</span>;</span><br></pre></td></tr></table></figure></li>
<li>边框图片<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">../images/border.png</span>) <span class="number">27</span>/<span class="number">20px</span> round;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>还没细看</p>
<h4 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h4><p>还没细看</p>
<h4 id="如何让一个元素水平垂直居中"><a href="#如何让一个元素水平垂直居中" class="headerlink" title="如何让一个元素水平垂直居中"></a>如何让一个元素水平垂直居中</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 绝对位置加上transform --&gt;</span></span><br><span class="line">        .father&#123;</span><br><span class="line">            position: relative;</span><br><span class="line">            min-height: 500px;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        .son &#123;</span><br><span class="line">            position: absolute;</span><br><span class="line">            background: red;</span><br><span class="line">            top: 50%;</span><br><span class="line">            left: 50%;</span><br><span class="line">            transform: translate(-50%, -50%);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- flex布局 --&gt;</span></span><br><span class="line">        .father&#123;</span><br><span class="line">            display: flex;</span><br><span class="line">            min-height: 100vh;</span><br><span class="line">            background: pink;</span><br><span class="line">        &#125;</span><br><span class="line">        .son &#123;</span><br><span class="line">            margin: auto;</span><br><span class="line">            background: red;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>note</category>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>note_css</title>
    <url>/2024/01/23/note-css/</url>
    <content><![CDATA[<p>闲得慌写点笔记。</p>
<h1 id="CSS：Cascading-Style-Sheet，层叠样式表"><a href="#CSS：Cascading-Style-Sheet，层叠样式表" class="headerlink" title="CSS：Cascading Style Sheet，层叠样式表"></a>CSS：Cascading Style Sheet，层叠样式表</h1><h2 id="CSS的引入方式"><a href="#CSS的引入方式" class="headerlink" title="CSS的引入方式"></a>CSS的引入方式</h2><ul>
<li>适合局部：行内样式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span> = <span class="string">&quot;color: red;&quot;</span>&gt;</span>我是行内样式<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>内嵌样式<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span> = <span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">    <span class="selector-tag">p</span> &#123;</span></span><br><span class="line"><span class="language-css">        <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">    &#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>引入外部css文件<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span> = <span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span> = <span class="string">&quot;text/css&quot;</span> <span class="attr">href</span> = <span class="string">&quot;css/a.css&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><ul>
<li>标签选择器：针对一类标签</li>
<li>ID 选择器：针对某一个特定的标签使用 <strong>唯一</strong></li>
<li>类选择器：针对你想要的所有标签使用<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 同一个标签使用多个类选择器，用 空格隔开*/</span></span><br><span class="line">&lt;<span class="selector-tag">div</span> class = &quot;one two&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span> class = &quot;one&quot;&gt;&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 正确的思路，就是用所谓“公共类”的思路，就是我们类就是提供“公共服务”，比如有绿、大、线，一旦携带这个类名，就有相应的样式变化。对应 css 里的代码如下： */</span></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.lv</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: green;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.da</span> &#123;</span><br><span class="line">        <span class="attribute">font-size</span>: <span class="number">30px</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-class">.underline</span> &#123;</span><br><span class="line">        <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line"><span class="comment">/* 然后让每个标签去选取自己想要用的类选择器： */</span></span><br><span class="line">&lt;<span class="selector-tag">p</span> class=&quot;lv da&quot;&gt;段落<span class="number">1</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span> class=&quot;lv xian&quot;&gt;段落<span class="number">2</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">p</span> class=&quot;da xian&quot;&gt;段落<span class="number">3</span>&lt;/<span class="selector-tag">p</span>&gt;</span><br></pre></td></tr></table></figure></li>
<li>通用选择器（通配符）：针对所有的标签都适用（不建议使用）</li>
</ul>
<p>一个标签可以被多个css选择器选择，这是cascading的第一层含义。比如选了id又选了标签。</p>
<p>那么经验上，不要试图用一个类选择器把某个标签的所有样式写完，类选择器要解耦，共同完成某个标签样式，方便复用。</p>
<p>也就是说类要尽可能小，<strong>突出一个公共</strong></p>
<p>id选择器一般给js用，写css用class选择器</p>
<ul>
<li><p>后代选择器</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* div1的所有后代p */</span></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.div1</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>
<p><img src="/pic/image.png" alt="后代选择器"></p>
</li>
<li><p>交集选择器<br><strong>注意没有空格 有空格就是后代</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>交集选择器测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css">            <span class="selector-tag">h3</span><span class="selector-class">.special</span> &#123;</span></span><br><span class="line"><span class="language-css">                <span class="attribute">color</span>: red;</span></span><br><span class="line"><span class="language-css">            &#125;</span></span><br><span class="line"><span class="language-css">        </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;special zhongyao&quot;</span>&gt;</span>标题1<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h3</span> <span class="attr">class</span>=<span class="string">&quot;special&quot;</span>&gt;</span>我也是标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>并集选择器<br>用逗号隔开</p>
</li>
</ul>
<h3 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h3><ul>
<li>子代选择器<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* div1的直接子代p */</span></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.div1</span> &gt; <span class="selector-tag">p</span> &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li>序选择器<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* div1的第一个p */</span></span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">    <span class="selector-class">.div1</span> <span class="selector-tag">p</span><span class="selector-pseudo">:first</span>-child &#123;</span><br><span class="line">        <span class="attribute">color</span>: red;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CSS选择器：伪类"><a href="#CSS选择器：伪类" class="headerlink" title="CSS选择器：伪类"></a>CSS选择器：伪类</h2><p>好像写的有点过于繁复了，写简单点。<br>超链接a标签有四种伪类 对应四种状态</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">	<span class="comment">/*让超链接点击之前是红色*/</span></span><br><span class="line">	<span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;</span><br><span class="line">		<span class="attribute">color</span>:red;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*让超链接点击之后是绿色*/</span></span><br><span class="line">	<span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;</span><br><span class="line">		<span class="attribute">color</span>:orange;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*鼠标悬停，放到标签上的时候*/</span></span><br><span class="line">	<span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;</span><br><span class="line">		<span class="attribute">color</span>:green;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*鼠标点击链接，但是不松手的时候*/</span></span><br><span class="line">	<span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;</span><br><span class="line">		<span class="attribute">color</span>:black;</span><br><span class="line">	&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>超链接是有四个伪类，它后面两个动态伪类：hover ：active加上个 ：focus是对所有标签都可以用的动态伪类</p>
<h2 id="CSS继承性"><a href="#CSS继承性" class="headerlink" title="CSS继承性"></a>CSS继承性</h2><p>有一些属性，当给自己设置的时候，自己的后代都继承上了，这个就是继承性。<br>关于文字样式的属性，都具有继承性。这些属性包括：color、 text-开头的、line-开头的、font-开头的。</p>
<p>关于盒子、定位、布局的属性，都不能继承。</p>
<h2 id="CSS层叠性"><a href="#CSS层叠性" class="headerlink" title="CSS层叠性"></a>CSS层叠性</h2><p>层叠性：就是css处理冲突的能力。 所有的权重计算，没有任何兼容问题！</p>
<p>当多个选择器，选择上了某个元素的时候，要按照如下顺序统计权重：</p>
<ul>
<li>id 选择器</li>
<li>类选择器、属性选择器、伪类选择器</li>
<li>标签选择器、伪元素选择器<br><strong>一种笔试题型：计算权重</strong><br><img src="/pic/image-1.png" alt="层叠性"><br>权重相同时<br><img src="/pic/image-2.png" alt="Alt text"><br>实战一般这么写<br><img src="/pic/image-3.png" alt="Alt text"><blockquote>
<p>为了达到这种效果，即为了防止权重不够，比较稳妥的做法是：把第二个样式表照着第一个样式表来写，在此基础上，给第二个样式表再加一个权重。上面这个例子很具有实战性。</p>
</blockquote>
</li>
</ul>
<p>继承不带来权重；<br>同权重就近原则；<br><img src="/pic/image-4.png" alt="Alt text"></p>
<details>
<summary>总结</summary>
1、对于相同的选择器（比如同样都是类选择器），其样式表排序：行级样式 > 内嵌样式表 > 外部样式表（就近原则）
2、对于相同类型的样式表（比如同样都是内部样式表），其选择器排序：ID选择器 > 类选择器 > 标签选择器
3、外部样式表的ID选择器 > 内嵌样式表的标签选择器
> 总结：就近原则。ID选择器优先级最大。
</details>

<p><em>k:v !important; 影响直接影响的当前属性权重，不影响继承权重，除非直接影响要不不考虑</em></p>
]]></content>
      <categories>
        <category>note</category>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>note-js</title>
    <url>/2024/01/23/note-js/</url>
    <content><![CDATA[<h2 id="不知道怎么起标题了"><a href="#不知道怎么起标题了" class="headerlink" title="不知道怎么起标题了"></a>不知道怎么起标题了</h2><p>要肝吐了</p>
<h2 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h2><p>不传参数，返回当前时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> date = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date);</span><br></pre></td></tr></table></figure>
<p>传参数，返回指定时间</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是字符串</span></span><br><span class="line"><span class="keyword">const</span> date11 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020/02/17 21:00:00&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date11); <span class="comment">// Mon Feb 17 2020 21:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> date12 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020/04/19&#x27;</span>); <span class="comment">// 返回的就是四月</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date12); <span class="comment">// Sun Apr 19 2020 00:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> date13 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;2020-05-20&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date13); <span class="comment">// Wed May 20 2020 08:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> date14 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&#x27;Wed Jan 27 2017 12:00:00 GMT+0800 (中国标准时间)&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date14); <span class="comment">// Fri Jan 27 2017 12:00:00 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是数字</span></span><br><span class="line"><span class="keyword">const</span> date21 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2020</span>, <span class="number">1</span>, <span class="number">17</span>, <span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date21); <span class="comment">// Mon Feb 17 2020 21:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"><span class="comment">//注意月份是从0开始的，所以2月是1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 参数是时间戳</span></span><br><span class="line"><span class="keyword">const</span> date31 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">1581939600000</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date31); <span class="comment">// Mon Feb 17 2020 21:00:00 GMT+0800 (中国标准时间)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 先把时间对象转换成时间戳，然后把时间戳转换成时间对象</span></span><br><span class="line"><span class="keyword">const</span> timestamp = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>();</span><br><span class="line"><span class="keyword">const</span> date32 = <span class="keyword">new</span> <span class="title class_">Date</span>(timestamp);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date32); <span class="comment">// Fri Jun 12 2020 16:28:21 GMT+0800 (中国标准时间)</span></span><br></pre></td></tr></table></figure>

<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sum</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">	<span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;我是匿名函数中封装的代码&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><ol>
<li>普通函数的调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="title function_">fn1</span>(); <span class="comment">// 调用函数</span></span><br><span class="line"></span><br><span class="line">fn2.<span class="title function_">call</span>(); <span class="comment">// 调用函数</span></span><br><span class="line">fn2.<span class="title function_">apply</span>(); <span class="comment">// 调用函数</span></span><br></pre></td></tr></table></figure></li>
<li>对象调用<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">a</span>: <span class="string">&#x27;qianguyihao&#x27;</span>,</span><br><span class="line">	<span class="attr">fn2</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;千古壹号，永不止步!&#x27;</span>);</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">fn2</span>(); <span class="comment">// 调用函数</span></span><br></pre></td></tr></table></figure></li>
<li>立即执行函数<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现有匿名函数如下：</span></span><br><span class="line">	<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">//立即执行函数如下：</span></span><br><span class="line"></span><br><span class="line">	(<span class="keyword">function</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;a = &quot;</span> + a);</span><br><span class="line">		<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;b = &quot;</span> + b);</span><br><span class="line">	&#125;)(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure>
IIFE的作用:将全局变量变为局部变量,闭包的作用:将函数内部的变量变为局部变量<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//现有如下代码：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">2</span>](); <span class="comment">// 打印5</span></span><br><span class="line"><span class="comment">//我们知道，上方代码中，i 是全局变量，所有函数共享内存中的同一个变量i。现在，我们通过立即执行函数进行改造：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="keyword">function</span> (<span class="params">i</span>) &#123;</span><br><span class="line">    arr.<span class="title function_">push</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(i);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)(i);</span><br><span class="line">&#125;</span><br><span class="line">arr[<span class="number">2</span>](); <span class="comment">// 打印2</span></span><br><span class="line"><span class="comment">//上方代码中，i作为传递给了IIFE的形参，让 i 得以成为 IIFE 的局部变量；并让 IIFE 并形成了闭包（arr[2]()打印出了IIFE内部变量 i 的值，说明形成了闭包）。</span></span><br></pre></td></tr></table></figure>
当使用 var 关键字声明变量时，它们具有函数作用域。函数作用域意味着变量的可见性仅限于声明它们的函数内部。在这种情况下，i 是在 for 循环的作用域中声明的，并且该作用域在整个循环过程中是共享的。</li>
</ol>
<p>在第二段代码中，for 循环迭代期间，每次都会创建一个匿名函数，并将这些函数添加到数组 arr 中。这些函数共享相同的作用域，即 for 循环的作用域。因此，它们都可以访问和引用相同的变量 i。</p>
<p>当循环结束时，变量 i 的值为 5。由于这些函数是在循环期间创建的，它们引用的是相同的变量 i。当调用 arr<a href="">2</a> 时，实际上是执行了数组中索引为 2 的函数，该函数会打印变量 i 的值。由于 i 的值在循环结束时是 5，因此打印的结果是 5。</p>
<p>这种现象被称为”闭包延迟绑定”，即在函数被调用时才获取变量的值，而不是在函数被创建时获取。在第二段代码中，当函数被调用时，它们引用的是循环结束时的变量 i 的值，而不是它们被创建时的值。</p>
<p>为了解决这个问题，第一段代码使用了立即执行函数表达式（IIFE）。IIFE 是一个立即执行的函数，它创建了一个新的作用域，并将当前的 i 值作为参数传递给该函数。每个迭代会创建一个新的作用域，保留了当前迭代的 i 值。通过这种方式，每个函数都有自己的闭包环境，它们分别引用了不同的 i 值。因此，调用 arr<a href="">2</a> 时，打印的是闭包环境中保留的值，即 2。</p>
<p>总结起来，第一段代码中的 IIFE 创建了闭包，它们保留了每个迭代中的 i 值，而第二段代码中的函数共享同一个作用域，它们引用的是循环结束时的 i 值。这导致在调用时打印的结果不同。</p>
<h2 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h2><p><strong>arguments</strong> 是一个类数组对象，它有一个 length 属性，但它不是一个 Array。<br>是传进来的参数，可以通过 arguments[0] 来访问第一个参数，arguments[1] 来访问第二个参数，以此类推。<br>在使用函数递归调用时，推荐使用 arguments.callee 代替函数名本身。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><strong>ES5</strong>：全局作用域的预处理：JS在解析的时候，会把变量的声明（用var声明的）提升到当前作用域的最前面，但是赋值不会提升。<br>只是声明提升，不会提前赋值。<br>函数作用域：函数中，使用 var 关键字声明的变量，会在函数中所有代码执行之前被提前声明。函数中，没有 var 声明的变量都是全局变量，且并不会被提前声明。<br>没有块级作用域：在 ES5 中，没有块级作用域的概念，只有全局作用域和函数作用域。</p>
<p>…arg  …arr<br>剩余参数  扩展运算符-用来转化为数组到真数组-用来数组赋值而不是浅拷贝-用来合并数组</p>
<p><a href="https://tech.meituan.com/2018/09/27/fe-security.html">https://tech.meituan.com/2018/09/27/fe-security.html</a></p>
<p>原型链本质是一个原型对象的单链表</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>简单的理解 <a href="https://www.bilibili.com/video/BV1Jm4y1v773/?spm_id_from=333.788&vd_source=aa13acd135b592a2a91f229a82aa2f5d">https://www.bilibili.com/video/BV1Jm4y1v773/?spm_id_from=333.788&amp;vd_source=aa13acd135b592a2a91f229a82aa2f5d</a></p>
]]></content>
      <categories>
        <category>note</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>diary0124</title>
    <url>/2024/01/24/diary0124/</url>
    <content><![CDATA[<p>学了一下午js。<br>写了一晚上BDA新闻分类。<br>傻逼模型在存储后跑在验证集上准确率只剩0.12。<br>我是在debug三小时后发现这一点的。<br>在此之前我以为只是新数据集的问题。<br>妈的。<br>现在加了随机数种子跑，重跑个逻辑回归，重新训练一下。<br>其实我一点原理都不懂。模模糊糊有个概念。<br>真尼玛折磨。</p>
]]></content>
  </entry>
  <entry>
    <title>note-js-async</title>
    <url>/2024/01/24/note-js-async/</url>
    <content><![CDATA[<p><strong>Promise的事情</strong><br>用一个array存储异步操作，然后用Promise.all来执行，只要有一个reject，就会返回reject方法的值，如果都resolve了，就会返回一个数组，数组里是每个异步操作的返回值</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> param_arr = [];</span><br><span class="line"><span class="keyword">const</span> promises = param_arr.<span class="title function_">map</span>(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 异步操作</span></span><br><span class="line">        <span class="keyword">if</span> (param) &#123;</span><br><span class="line">            <span class="title function_">resolve</span>(param);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="title function_">reject</span>(<span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>(promises).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>用allSettled来执行，不管resolve还是reject，都会返回一个数组，数组里是每个异步操作的返回值</p>
<p><strong>async&#x2F;await的事情</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">getUserData</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用 Promise.all() 并行获取数据</span></span><br><span class="line">    <span class="keyword">const</span> [userInfo, userPosts, userComments] = <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">      <span class="title function_">fetchUserInfo</span>(userId),</span><br><span class="line">      <span class="title function_">fetchUserPosts</span>(userId),</span><br><span class="line">      <span class="title function_">fetchUserComments</span>(userId)</span><br><span class="line">    ]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      userInfo,</span><br><span class="line">      userPosts,</span><br><span class="line">      userComments</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching user data:&#x27;</span>, error);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUserInfo</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`/api/users/<span class="subst">$&#123;userId&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching user info:&#x27;</span>, error);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUserPosts</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`/api/users/<span class="subst">$&#123;userId&#125;</span>/posts`</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching user posts:&#x27;</span>, error);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">fetchUserComments</span>(<span class="params">userId</span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> response = <span class="keyword">await</span> axios.<span class="title function_">get</span>(<span class="string">`/api/users/<span class="subst">$&#123;userId&#125;</span>/comments`</span>);</span><br><span class="line">    <span class="keyword">return</span> response.<span class="property">data</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error fetching user comments:&#x27;</span>, error);</span><br><span class="line">    <span class="keyword">throw</span> error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 getUserData 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> userData = <span class="keyword">await</span> <span class="title function_">getUserData</span>(<span class="number">123</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;User Info:&#x27;</span>, userData.<span class="property">userInfo</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;User Posts:&#x27;</span>, userData.<span class="property">userPosts</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;User Comments:&#x27;</span>, userData.<span class="property">userComments</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&#x27;Error:&#x27;</span>, error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>note</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>diary0125</title>
    <url>/2024/01/25/diary0125/</url>
    <content><![CDATA[<p>完蛋。<br>今天好像啥也没做。<br>我下午做了啥来着？<br>晚上和哈提聊了下简历，受益匪浅。<br>定好接下来计划，然后，<br>休假。</p>
]]></content>
  </entry>
  <entry>
    <title>diary0301</title>
    <url>/2024/03/01/diary0301/</url>
    <content><![CDATA[<p>好吧，今天终于把那份很糙的简历都投了下。<br>腾讯美团vivo</p>
<h2 id="JS函数式编程"><a href="#JS函数式编程" class="headerlink" title="JS函数式编程"></a>JS函数式编程</h2>]]></content>
  </entry>
  <entry>
    <title>diary0224</title>
    <url>/2024/02/24/diary0224/</url>
    <content><![CDATA[<p>谁能想到这个假休得这么长呢？<br>同时它又很短。<br>好吧，不管怎么说，寒假结束了。</p>
]]></content>
  </entry>
  <entry>
    <title>diary0309</title>
    <url>/2024/03/09/diary0309/</url>
    <content><![CDATA[<h2 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h2><ol>
<li><p>进程和线程概念</p>
</li>
<li><p>并发和并行<br>并发是指一个处理器同时处理多个任务，而并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。</p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>diary0307</title>
    <url>/2024/03/07/diary0307/</url>
    <content><![CDATA[<p>欠下的牛逼终归要还的。<br>离面试还有四天，让我看看我能不能把这些给整明白。</p>
<h2 id="首先是CSS"><a href="#首先是CSS" class="headerlink" title="首先是CSS"></a>首先是CSS</h2><p>Less干了什么呢，让css需要编译了，浏览器不能直接执行了。<br>他有一些特性可以帮助css更方便写。<br>嵌套 更直观体现父选择器和后代选择器关系<br>混入 把一段css相同的代码放到另一个选择器里面<br>@变量 更方便</p>
<h2 id="less和sass的区别是什么"><a href="#less和sass的区别是什么" class="headerlink" title="less和sass的区别是什么"></a>less和sass的区别是什么</h2><p>它们的目标都是通过引入一些编程语言的特性来增强CSS的功能<br>语法上有点区别<br>Less使用JavaScript实现，它依赖于浏览器端或服务器端的JavaScript执行环境进行编译<br>sass ruby</p>
<h2 id="为什么说js是解释型语言"><a href="#为什么说js是解释型语言" class="headerlink" title="为什么说js是解释型语言"></a>为什么说js是解释型语言</h2><p>因为js是一行行边编译边执行的，而不是先全转译成机器码<br>至于说他是动态的，是因为它的类型是在运行时才确定的而不是编译时。</p>
<h2 id="函数式编程是什么"><a href="#函数式编程是什么" class="headerlink" title="函数式编程是什么"></a>函数式编程是什么</h2><p>拉姆达演算开始的</p>
<blockquote>
<p>在前端领域, 我们同样能看到很多函数式编程的影子: ES6 中的新增的箭头函数, react 中大量使用函数式编程, Vue3 也开始拥抱函数式编程…<br>核心是无状态和数据不可变<br>无状态就是一个函数不管什么时候用给同样输入输出应该是一样的，不依赖外部状态；<br>数据不可变就是不该原来的对象而是创建一个新的对象</p>
</blockquote>
<h3 id="没有副作用-数据不变"><a href="#没有副作用-数据不变" class="headerlink" title="没有副作用(数据不变)"></a>没有副作用(数据不变)</h3><p>给两段代码直观看</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [...];</span><br><span class="line"><span class="comment">// 修改 list 中的 type 和 age</span></span><br><span class="line">list.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  item.<span class="property">type</span> = <span class="number">1</span>;</span><br><span class="line">  item.<span class="property">age</span>++;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [...];</span><br><span class="line"><span class="comment">// 修改 list 中的 type 和 age</span></span><br><span class="line"><span class="keyword">const</span> newList = list.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (&#123;...item, <span class="attr">type</span>: <span class="number">1</span>, <span class="attr">age</span>:item.<span class="property">age</span> + <span class="number">1</span>&#125;));</span><br></pre></td></tr></table></figure>
<h3 id="不依赖外部状态-无状态"><a href="#不依赖外部状态-无状态" class="headerlink" title="不依赖外部状态(无状态)"></a>不依赖外部状态(无状态)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">saySth</span> = str =&gt; curUser.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> + str;   <span class="comment">// 引用了全局变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params">obj, name</span>) =&gt; obj.<span class="property">name</span> = name;  <span class="comment">// 修改了输入参数</span></span><br><span class="line"><span class="title function_">changeName</span>(curUser, <span class="string">&#x27;Jay&#x27;</span>);  <span class="comment">// &#123; name: &#x27;Jay&#x27; &#125;</span></span><br><span class="line"><span class="title function_">saySth</span>(<span class="string">&#x27;hello!&#x27;</span>); <span class="comment">// Jay: hello!</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> curUser = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Peter&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">saySth</span> = (<span class="params">user, str</span>) =&gt; user.<span class="property">name</span> + <span class="string">&#x27;: &#x27;</span> + str;   <span class="comment">// 不依赖外部变量</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">changeName</span> = (<span class="params">user, name</span>) =&gt; (&#123;...user, name &#125;);  <span class="comment">// 未修改外部变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newUser = <span class="title function_">changeName</span>(curUser, <span class="string">&#x27;Jay&#x27;</span>);  <span class="comment">// &#123; name: &#x27;Jay&#x27; &#125;</span></span><br><span class="line"><span class="title function_">saySth</span>(curUser, <span class="string">&#x27;hello!&#x27;</span>); <span class="comment">// Peter: hello!</span></span><br></pre></td></tr></table></figure>

<p>currying 柯里化 将一个多元函数转换成多个一元函数<br>函数组合</p>
<p>缺点：性能，资源占用，递归</p>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p><a href="https://juejin.cn/post/6844903887795650573">https://juejin.cn/post/6844903887795650573</a><br><a href="https://poe.com/chat/22rmb37lente5e0uk8v">https://poe.com/chat/22rmb37lente5e0uk8v</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* Webpack是一个现代化的前端构建工具，它的出现是为了解决前端开发中的模块化和构建问题。</span><br><span class="line"></span><br><span class="line">在过去，前端开发中使用的是传统的脚本标签引入方式，每个页面都需要手动引入各个依赖的脚本文件，这样会导致页面结构混乱、代码复用性差，并且难以管理项目中的大量依赖。同时，前端开发中使用的语言和框架也越来越复杂，需要将代码拆分成多个模块进行开发和维护。</span><br><span class="line"></span><br><span class="line">Webpack的出现解决了这些问题。它可以将前端项目中的各种资源，如JavaScript、CSS、图片等，都视为模块，并通过配置文件定义各个模块之间的依赖关系。然后，Webpack会根据这些配置，将模块打包成静态资源文件，以供浏览器加载和解析。</span><br><span class="line"></span><br><span class="line">Webpack具有以下主要功能和特点：</span><br><span class="line">1. 模块化管理：Webpack支持使用ES6的import语法和CommonJS的require语法等方式来引入模块，并且可以处理模块之间的依赖关系，实现代码的模块化管理。</span><br><span class="line">2. 打包和压缩：Webpack可以将多个模块打包成一个或多个静态资源文件，减少了浏览器加载的请求数量，并且可以通过各种优化手段来压缩代码，减小文件体积，提高页面加载速度。</span><br><span class="line">3. 资源优化：Webpack可以处理各种类型的资源，如CSS、图片等，并且可以对它们进行优化，如压缩、合并、转换格式等，以提高页面性能。</span><br><span class="line">4. 插件系统：Webpack提供了丰富的插件系统，可以通过插件扩展其功能，例如自动化构建、代码分割、按需加载等。</span><br><span class="line">5. 开发环境支持：Webpack提供了开发环境的支持，包括文件监听、热模块替换等功能，可以提高开发效率。</span><br><span class="line">loader entry output plugins </span><br><span class="line"></span><br><span class="line">总的来说，Webpack的出现是为了解决前端开发中的模块化和构建问题，使得前端开发更加高效、灵活，并且可以提供优化和扩展的能力。*/</span><br></pre></td></tr></table></figure>
<p>1**	信息，服务器收到请求，需要请求者继续执行操作 100<br>2**	成功，操作被成功接收并处理 200 204<br>3**	重定向，需要进一步的操作以完成请求<br>4**	客户端错误，请求包含语法错误或无法完成请求 400 401 403 404 分别代表请求错误，未授权，禁止访问，未找到<br>5**	服务器错误，服务器在处理请求的过程中发生了错误</p>
]]></content>
  </entry>
  <entry>
    <title>diary0312</title>
    <url>/2024/03/12/diary0312/</url>
    <content><![CDATA[<p>一个值得记录的发现。<br>useState的维护挺复杂的。<br>setState并不是立即生效的，而是在下一次渲染时生效。</p>
]]></content>
  </entry>
  <entry>
    <title>js-base-1</title>
    <url>/2024/04/08/js-base-1/</url>
    <content><![CDATA[<h2 id="for-each和map"><a href="#for-each和map" class="headerlink" title="for each和map"></a>for each和map</h2><p>for each只是遍历，不会返回新数组，对</p>
<h2 id="for-of-和-for-in"><a href="#for-of-和-for-in" class="headerlink" title="for of 和 for in"></a>for of 和 for in</h2><p>for of遍历数组值，for in遍历对象的键</p>
<h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p><a href="https://juejin.cn/post/">https://juejin.cn/post/</a> 复习过一下</p>
<p>记笔记啊<br>还有继承</p>
<h2 id="bind-apply-call"><a href="#bind-apply-call" class="headerlink" title="bind apply call"></a>bind apply call</h2><p>bind返回一个函数，apply和call立即执行<br>，apply和call的区别是参数的传递方式不同，apply是数组，call是逗号分隔的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line">fn.<span class="title function_">call</span>(&#123;<span class="attr">x</span>: <span class="number">100</span>&#125;, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">fn.<span class="title function_">apply</span>(&#123;<span class="attr">x</span>: <span class="number">100</span>&#125;, [<span class="number">1</span>, <span class="number">2</span>]);</span><br><span class="line">fn.<span class="title function_">bind</span>(&#123;<span class="attr">x</span>: <span class="number">100</span>&#125;)(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p>this是函数运行时自动生成的一个对象，指向函数的调用者</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>

<h3 id="this的指向"><a href="#this的指向" class="headerlink" title="this的指向"></a>this的指向</h3><p>举例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> fn = obj.<span class="property">fn</span>;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
<p>this指向全局对象，因为fn是全局函数</p>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&#x27;use strict&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
<p>严格模式下this指向undefined</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">a</span> = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br></pre></td></tr></table></figure>
<p>this指向实例对象</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
<p>this指向全局对象，为什么</p>
<h3 id="call-apply-bind"><a href="#call-apply-bind" class="headerlink" title="call apply bind"></a>call apply bind</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="attr">fn</span>: <span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">a</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="property">fn</span>.<span class="title function_">call</span>(obj2);</span><br><span class="line">obj.<span class="property">fn</span>.<span class="title function_">apply</span>(obj2);</span><br><span class="line">obj.<span class="property">fn</span>.<span class="title function_">bind</span>(obj2)();</span><br></pre></td></tr></table></figure>
<p>call apply bind可以改变this的指向</p>
<h2 id="严格模式-1"><a href="#严格模式-1" class="headerlink" title="严格模式"></a>严格模式</h2><p>记两个就行<br>this不能指向全局对象;<br>a &#x3D; 1; 不能直接赋值;</p>
]]></content>
      <categories>
        <category>note</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>现在开始当然是最好的时间</title>
    <url>/2024/03/19/diary0319/</url>
    <content><![CDATA[<p>面腾讯第二次了。<br>这次是腾讯云。<br>面试内容：1.js基础（数据类型有哪些，闭包） 2.项目里面写的（媒体响应布局&#x3D;&gt;flex了解哪些，如果我要一个盒子左边右边自适应满怎么做） 3.react基础（hooks有哪些，useeffect传了哪些参数，返回值是什么，map有返回值吗） 4.算法题：比较两个对象是否相等，有嵌套字段；将多维数组拍成一维数组，有嵌套[1,2,[3,4],5,[6]];<br>反思：1.数据类型没说全，闭包没说全 2.响应布局怎么做要看，flex布局也要看 3.react基础，hooks没说全，useeffect不会，map不知道有没有返回值 4.算法题，如果前面答得好，api不熟没做出来，有个思路也行。<br>总结：1.js书蛮看 2.计网基础要看 跨域，浏览器请求 要理解深点 3.react基础要看文档 4.算法题要多做递归，数组，对象处理 相关API要熟悉</p>
<hr>
<p>美团一面 挂<br>问题出在基础，简历上写的东西要有深入了解 react生命周期 this指向生命周期<br>相对定位<br>响应式布局写了就要懂有哪些方法，就算还没实践，知道有哪几种。<br>浏览器存储有哪些。<br>get和post区别，深入，登录怎么做<br>交互体验，你认为好的交互体验<br>css的继承 定位</p>
<p>简历上有些就要有深入理解，大部分面试官专注于以简历上写的为基础。</p>
<p>还有就是算法题要专注于题目，别紧张，老是断思路，可以试着写出思路。<br>react的搭建<br>root.render<br>生命周期</p>
<h3 id="好的"><a href="#好的" class="headerlink" title="好的"></a>好的</h3><p>我现在对于浏览器的运行，输入请求发生了什么，get post的区别有了表层的理解<br>浏览器是一个有很多进程的结构，作为用户代理，包括渲染进程，浏览器进程（用于管理进程，缓存，gpu，网络；<br>html dom css layout 栅格化 gpu</p>
<p>get和post都是http的东西，http是tcp内的其中一种协议，没有本质区别，通常get用于获取资源，post用于提交资源，get的参数在url上，post的参数在请求体里，get的参数有长度限制，post没有，get的参数会被缓存，post不会，get的参数会被记录在浏览器历史里，post不会，get的参数会被记录在服务器日志里，post不会，get的参数可以被收藏为书签，post不会，get的参数只能进行url编码，post可以用formdata编码，get的参数可以被缓存，post不会，get的参数对于搜索引擎友好</p>
<h3 id="那么"><a href="#那么" class="headerlink" title="那么"></a>那么</h3><p>浏览器事件循环机制是什么呢？<br>…b站收藏</p>
<p>响应式布局<br>列表手机端怎么做适应</p>
<h3 id="呜"><a href="#呜" class="headerlink" title="呜"></a>呜</h3><p>hash history<br>登录<br>cookie session token<br><a href="https://zhuanlan.zhihu.com/p/631349844">https://zhuanlan.zhihu.com/p/631349844</a></p>
<p>闭包<br>私有变量和函数，避免全局命名冲突 和 变量污染，惰性求值<br><a href="https://zhuanlan.zhihu.com/p/25489604">https://zhuanlan.zhihu.com/p/25489604</a></p>
<p>如何使用函数式编程<br>函数式编程有什么好处</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">函数式编程是一种编程范式，它将计算视为数学函数的求值过程，并强调使用纯函数（Pure Function）作为构建块来进行程序开发。在函数式编程中，函数被视为一等公民，可以作为参数传递给其他函数，也可以作为返回值。函数式编程强调使用不可变数据和避免副作用，即函数在执行过程中不会修改传入的参数或产生其他可观察的影响。</span><br><span class="line"></span><br><span class="line">要使用函数式编程，你可以遵循以下几个主要的原则和技术：</span><br><span class="line"></span><br><span class="line">1. 使用纯函数：纯函数是没有副作用的函数，它的输出仅由输入决定，不依赖于外部状态。通过使用纯函数，可以提高代码的可测试性和可维护性。</span><br><span class="line"></span><br><span class="line">2. 不可变数据：函数式编程鼓励使用不可变数据，即数据在创建后不可修改。这样可以避免意外的数据修改和共享数据导致的并发问题。</span><br><span class="line"></span><br><span class="line">3. 高阶函数：高阶函数是指可以接受一个或多个函数作为参数，或者返回一个新函数的函数。通过使用高阶函数，可以实现函数的组合和抽象，提高代码的模块化和复用性。</span><br><span class="line"></span><br><span class="line">4. 递归：函数式编程通常使用递归来实现循环和迭代的效果。递归是一种自我引用的技术，可以遍历和处理数据结构。</span><br><span class="line"></span><br><span class="line">函数式编程有以下几个好处：</span><br><span class="line"></span><br><span class="line">1. 可维护性：函数式编程鼓励使用纯函数和不可变数据，这样可以减少代码的副作用和意外修改，使代码更易于理解和维护。</span><br><span class="line"></span><br><span class="line">2. 可测试性：由于函数式编程重视纯函数，函数的输出仅由输入决定，因此可以更容易地编写和执行单元测试。</span><br><span class="line"></span><br><span class="line">3. 并发和并行性：由于函数式编程避免了共享数据和副作用，因此在并发和并行编程中更容易实现线程安全性。</span><br><span class="line"></span><br><span class="line">4. 可扩展性：函数式编程强调函数的组合和抽象，可以通过将小的函数组合成更大的函数来构建复杂的系统，从而提高代码的可扩展性。</span><br><span class="line"></span><br><span class="line">需要注意的是，函数式编程并不是适用于所有场景的银弹，它在某些问题领域和特定情况下可能比命令式编程更适用。因此，在选择使用函数式编程时，需要根据实际情况做出合适的权衡和决策。</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>diary0407</title>
    <url>/2024/04/07/diary0407/</url>
    <content><![CDATA[<p>第三次面腾讯 qq浏览器<br>问了很多计网相关 http协议 tcp&#x2F;udp</p>
<p>面携程<br>甚至没做题 基础不牢 知道但不深入 建议找一块大部分时间学<br>深入某一个方面 js 其他时间看一看</p>
<p>面淘天<br>html语义化标签 css </p>
<p>4&#x2F;10 面美团点评<br>感觉还行 如果不是kpi概率进二面</p>
<p>事件委托<br>冒泡 捕获<br>css选择器<br>迭代器<br><a href="https://zhuanlan.zhihu.com/p/165948917?utm_id=0">https://zhuanlan.zhihu.com/p/165948917?utm_id=0</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/08/js-base-1-t/</url>
    <content><![CDATA[function getThis() {
  return this;
}

console.log(Function.prototype);
console.log(Object.getPrototypeOf(getThis));

let age = 20;
function person(name, age) {
  this.name = name;
  this.age = age;
  this.say = function () {
    console.log(this.name + this.age);
  }

}
console.log(person.prototype);
person.prototype.do = function () {
  console.log("i do");
}
let p1 = new person('zhangsan', 20);
p1.do();
let pison = {
  age: 40,
  name: 'zhangsi',
  Bge: 50,
  bge: age,
  say: function () {
    console.log(this.name + this.bge);
  }
}
console.log(this);
console.log(pison);
p1.say();
pison.say();



let a = 'asdsd';
let b = 'asdsc';
let c = Symbol(a);
let d = Symbol(a);
a = parseInt(a);
console.log(a);
console.log(typeof c, d, c === d);
var arr = [1, 2, 3, 4, 5];
var num = 3;
arr.some(function (v) {
  if (v == num) {
    return;  // 
  }
  // console.log(v);
});
let af = [1, 2]
console.log(typeof af);
let z = 1;
let bb = {
  z: 1,
}
let cc = [z, 2]
a = 2
console.log(bb.z, cc[0]);

function exampleFunction2() {
  var x = "declared outside function";
  return x;
}
exampleFunction();

function exampleFunction() {
  console.log("Inside function");
  console.log(x);
}

console.log("Outside function");
console.log(x);


// foreach
var arr_ref = [{ a: 1 }, { b: 2 }, { c: 3 }];
arr_ref.forEach(function (v) {
  console.log(v);
  v["a"] = v["a"] + 1;
});
console.log(arr_ref);
var arr_base = [1, 2, 3, 4, 5];
arr_base.forEach(function (v) {
  console.log(v);
  v = v + 1;
  return v;
});
console.log(arr_base);

//浅拷贝
let arr_shallow = [1, 2, 3, 4, 5];
let arr_shallow_copy = arr_shallow.reverse();
console.log(arr_shallow);
arr_shallow_copy[0] = 100;
console.log(arr_shallow);
// reverse返回引用 slice返回新对象
//https://zhuanlan.zhihu.com/p/503311780

console.log(typeof function () { });
console.log(typeof [1, 2]);

let count_global = 0;
function createCounter() {
  let count = 0;

  return {
    increment: function () {
      count++;
      count_global++;
    },
    decrement: function () {
      count--;
    },
    getCount: function () {
      return [count, count_global];
    }
  };
}

const counter = createCounter();
const counter2 = createCounter();
counter.increment();
counter.increment();
console.log(counter.getCount());
counter2.increment();
counter2.increment();


console.log(counter2.getCount());



function f() {

  "use strict";
  console.log(this);
  this.a = 1;
  
};

f();// 报错，this未定义

const personPrototype = {
  greet() {
    console.log(`你好，我的名字是 ${this.name}！`);
  },
};

function Person2(name) {
  this.name = name;
}

Object.assign(Person2.prototype, personPrototype);
function Stuednt(name) {
  this.name = name;
}
Stuednt.prototype = Object.create(Person2.prototype);
// 或
// Person.prototype.greet = personPrototype.greet;
console.log(Object.getPrototypeOf(Stuednt.prototype));]]></content>
  </entry>
  <entry>
    <title>note-css-mdn-1</title>
    <url>/2024/04/24/note-css-mdn-1/</url>
    <content><![CDATA[<div style="font-family: '楷体', '黑体'; background-color: white;">
“为天地之无穷兮，哀人生之长勤”
</div>
<div style="font-family:'黑体'">
从今日始，从今日始。
</div>

<blockquote>
<p>html开发者工具文档<a href="https://firefox-source-docs.mozilla.org/devtools-user/page_inspector/how_to/examine_and_edit_html/index.html#html_tree">firefox</a></p>
</blockquote>
<h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: content-box | border-box | inherit;</span><br><span class="line"><span class="attribute">display</span>: block | inline | inline-block | none;</span><br></pre></td></tr></table></figure>
<h2 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h2><h3 id="响应式图片"><a href="#响应式图片" class="headerlink" title="响应式图片"></a>响应式图片</h3><blockquote>
<p>max-width:100% 相对父元素宽度</p>
</blockquote>
<h3 id="响应式的几种操作"><a href="#响应式的几种操作" class="headerlink" title="响应式的几种操作"></a>响应式的几种操作</h3><ul>
<li>@<strong>media</strong><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span>|<span class="keyword">only</span> mediatype <span class="keyword">and</span> (expressions) &#123;</span><br><span class="line">    CSS-<span class="selector-tag">Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>flex&#x2F;<strong>grid</strong></li>
<li>vw&#x2F;<strong>vh</strong></li>
<li>rem&#x2F;<strong>em</strong></li>
</ul>
<h2 id="流布局"><a href="#流布局" class="headerlink" title="流布局"></a>流布局</h2><p>flex的属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line"><span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br><span class="line"><span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line"><span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | </span><br><span class="line">space-around;</span><br><span class="line"><span class="comment">/* justify-content 控制 flex 项在主轴（横轴）上的位置。 */</span></span><br><span class="line"><span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line"><span class="comment">/* align-items 控制 flex 项在交叉轴（竖轴）上的位置。 */</span></span><br><span class="line"><span class="attribute">align-content</span>: flex-start | flex-end | center | space-between | </span><br><span class="line">space-around | stretch;</span><br><span class="line"><span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>flex游戏：<a href="https://flexboxfroggy.com/">https://flexboxfroggy.com/</a><br><a href="https://blog.csdn.net/cc18868876837/article/details/88138057">https://blog.csdn.net/cc18868876837/article/details/88138057</a> 看结论：就是align-content基本单位是子项构成的行，有space-between和space-around</p>
</blockquote>
]]></content>
      <categories>
        <category>note</category>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>note-js-this</title>
    <url>/2024/03/18/note-js-this/</url>
    <content><![CDATA[<p>普通函数里的this是调用的对象<br>回调函数里的this undefined，非严格模式下是window，严格模式下是undefined<br>箭头函数 不会创建新的this绑定，直接绑到函数创建时的this上<br>构造函数 this指向新创建的对象</p>
<p><strong>理解this指向</strong><br>出现在函数里面，是函数的一个内部属性或者说自有变量，指向函数的调用者<br>函数总是要被调用的，总要有一个对象调用它，this就是指向这个对象的，也就是堆里的一块数据<br>这个<strong>上下文对象是在函数调用时确定的</strong>，而不是在函数定义时确定的<br>那这样就好理解了</p>
<p>至于<strong>箭头函数</strong>比较特殊，它的this基于词法作用域从外层获得，什么意思呢，它的this是在定义时确定的，而不是在调用时确定的。这是因为箭头函数不会创建自己的 this 上下文，它们只会从自己被定义的环境中获取 this。所以它的this就是定义时的this，也就是<strong>外层函数的this</strong>，这样就不会出现this指向问题了<br><a href="https://fe.ecool.fun/topic/dbf9172e-1193-44cb-a534-3c16ae07de2d?orderBy=updateTime&order=desc&titleKey=this">https://fe.ecool.fun/topic/dbf9172e-1193-44cb-a534-3c16ae07de2d?orderBy=updateTime&amp;order=desc&amp;titleKey=this</a></p>
]]></content>
      <categories>
        <category>note</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/15/pdd/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/07/t/</url>
    <content><![CDATA[
<!DOCTYPE html>
<html>
<head>
  <title>导入 JavaScript 文件</title>
  <script src="test3.js"></script>
  <style>
    .container{
      display: flex;
      align-items: center;
    }
    .img{
      width: 100px;
      color: red;
      background-color: yellow;
    }
    .title{
      flex:1;/*占满剩余空间*/
      word-wrap: break-word;/*换行*/
      color: blue;
      background-color: pink;
    }
    .button{
      white-space: nowrap;/*不换行*/
      overflow: hidden;/*超出部分隐藏*/
      width:auto;/*自适应宽度*/
      color: green;
      background-color: lightblue;
    }

  </style>
</head>
<body>
    <div class="container">
        <img class="img" src="" />
        <div class="title">标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案文案标题文案标题文案</div>
        <div class="button">查看详情标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案标题文案</div>
    </div></body>
</html>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/03/31/tempCodeRunnerFile/</url>
    <content><![CDATA[function test() {
    this.a = 1;
}
let tt = new test();
test.prototype.b = 2;
console.log(tt.__proto__);]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/03/30/test/</url>
    <content><![CDATA[function create(transformers) {
    return function (template, ...args) {
        let idx = 0;
        let state = 'UNDEFINED';

        return template.replace(
            /([{}])\1|[{](.*?)(?:!(.+?))?[}]/g,
            function (match, literal, key, xf) {
                if (literal != null) {
                    return literal;
                }
                if (key.length > 0) {
                    if (state === 'IMPLICIT') {
                        throw ValueError('cannot switch from implicit to explicit numbering');
                    }
                    state = 'EXPLICIT';
                } else {
                    if (state === 'EXPLICIT') {
                        throw ValueError('cannot switch from explicit to implicit numbering');
                    }
                    state = 'IMPLICIT';
                    key = String(idx);
                    idx += 1;
                }

                // 补全代码: 根据占位符的 key 和 args 数组中的值，获取相应的 value
                // 提示：使用 key 和 args 数组来获取正确的 value
                let value = args[1];
                console.log(value)
                console.log('args',args)
                return String(value);
                if (xf == null) {
                    // 补全代码: 如果没有转换器 xf，返回获取到的 value

                } else if (transformers.hasOwnProperty(xf)) {
                    // 补全代码: 如果存在名为 xf 的转换器，将其应用于 value，并返回转换后的结果
                    // 提示：使用 transformers 对象来查找和应用转换器


                } else {
                    throw ValueError(`no transformer named "${xf}"`);
                }
            }
        );
    };
}
function ValueError(message) {
    var err = new Error(message);
    err.name = 'ValueError';
    return err;
}
console.log(create({})`{0} {1}!{upper}`('hello', 'world'));]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/02/test2/</url>
    <content><![CDATA[//大数相乘 两个代表非负整数的字符串 返回也是字符串 使用js
//输入：2342423423424234234234234234242342353454365 * 43543534643345343253464363454235234235345346
//输出：101997395487256741190161412236975225638701789029942886861208566826758303120581826135290
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

function big_multiply(a, b) {

    const len1 = a.length;
    const len2 = b.length;
    //console.log("num1:",a,len1);
    //console.log("num2:",b, len2);
    let result = new Array(len1 + len2).fill(0);
    for(let i = len1-1;i>=0;i--){
        for(let j = len2- 1;j>=0;j--){
            let tmp = Number(a[i])*Number(b[j]);
            //console.log("tmp:",tmp);
            let sum = tmp+result[i+j+1];
            result[i+j] += Math.floor(sum/10);
            result[i+j+1] = sum%10;
        }
    }
    while (result[0] === 0) {
        result.shift();
    }

    result = result.join('');
    //console.log( "correct:",(BigInt(a) * BigInt(b)).toString())

    return result;
}
rl.on('line', (line) => {
    const nums = line.split(' * ');
    const a = nums[0];
    const b = nums[1];
    console.log(big_multiply(a, b));
    rl.close();
});
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/06/test3/</url>
    <content><![CDATA[
//一个flex横向布局，左中右分别为img宽度固定为100px，title可换行布满剩余空间，button宽度不固定不许换行
<script>
var container = document.querySelector('.container');
var img = document.querySelector('.img');
var title = document.querySelector('.title');
var button = document.querySelector('.button');
container.style.display = 'flex';
container.style.alignItems = 'center';
img.style.width = '100px';
title.style.flex = '1';
title.style.wordWrap = 'break-word';
button.style.whiteSpace = 'nowrap';
button.style.overflow = 'hidden';
button.style.width = 'auto';
</script>

]]></content>
  </entry>
  <entry>
    <title>todew-demo</title>
    <url>/2024/05/09/todew-demo/</url>
    <content><![CDATA[<ol>
<li>draggble组件的使用，事件响应</li>
<li>ref绑定</li>
<li>css伪元素的使用</li>
<li><a href="https://desnlee.com/post/chat-gpt/">https://desnlee.com/post/chat-gpt/</a></li>
</ol>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/04/28/test4/</url>
    <content><![CDATA[function bubbleSort(nums) {
    if(nums.length<=1)return nums;
    for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < nums.length - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                let tmp = nums[j];
                let tmp2 = nums[j + 1];
                nums = nums.slice()
                nums[j] = tmp2;
                nums[j + 1] = tmp;
            }
        }
    }
    return nums;
}

function qsort(nums){
    if(nums.length<=1)return nums;
    let mid_index = Math.floor(nums.length/2)
    let mid = nums.splice(mid_index,1)[0];
    let left = [];
    let right = [];
    
    for(let i = 0;i<nums.length;i++){
        if(nums[i]<=mid){
            left.push(nums[i]);
        }else{
            right.push(nums[i])
        }
    }
    return qsort(left).concat(mid,qsort(right));
}
console.log(qsort([2,1,3,22,4]));
console.log([1,2,3].splice(1, 1)[0]);

console.log(bubbleSort([1,2,5,2,6]))
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/17/js-this-1/</url>
    <content><![CDATA[var a = 2;
globalThis.a = 3;
function tthis(a) {
    console.log(this.a);
    console.log("my a == ", a)
    return a * a;
}
this.a = 5;
// tthis(1);
//因为这里globalThis和this不是一个东西，nodejs模块的最顶层this是空的
Object.prototype.tthis = tthis;

globalThis.tthis(1);
console.log("================", this);
console.log("================", globalThis);
console.log("================", globalThis.tthis(4));

console.log("================", this.tthis(4));
console.log("================", tthis(4));
/**
这段代码主要涉及到 JavaScript 中的 `this` 关键字和原型链的使用。

首先，我们定义了一个全局变量 [`a`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A0%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 并赋值为 2，然后我们又在全局对象 [`globalThis`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A1%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 上定义了一个属性 [`a`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A0%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 并赋值为 3。在 JavaScript 中，全局变量实际上是全局对象的属性，所以这里 [`globalThis.a = 3;`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A1%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 实际上改变了全局变量 [`a`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A0%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 的值。

接着，我们定义了一个名为 [`tthis`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A2%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 的函数，这个函数接收一个参数 [`a`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A0%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js")，并在函数体内部打印 `this.a` 和 `"my a == ",a`，然后返回 [`a`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A0%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 的平方。这里的 `this.a` 是指调用这个函数的对象的 [`a`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A0%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 属性，如果没有指定调用对象，那么 `this` 就是全局对象。

然后，我们将 [`tthis`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A2%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 函数添加到 [`Object.prototype`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fd%253A%2FCode%2FMicrosoft%2520VS%2520Code%2Fresources%2Fapp%2Fextensions%2Fnode_modules%2Ftypescript%2Flib%2Flib.es5.d.ts%22%2C%22path%22%3A%22%2Fd%3A%2FCode%2FMicrosoft%20VS%20Code%2Fresources%2Fapp%2Fextensions%2Fnode_modules%2Ftypescript%2Flib%2Flib.es5.d.ts%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A122%2C%22character%22%3A0%7D%5D "d:/Code/Microsoft VS Code/resources/app/extensions/node_modules/typescript/lib/lib.es5.d.ts") 上，这意味着所有的对象都可以调用 [`tthis`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A2%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 方法。

最后，我们调用 `this.tthis(4)` 和 [`tthis(4)`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A2%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js")，并打印结果。这里的 `this` 是全局对象，所以 `this.tthis(4)` 实际上是调用全局对象的 [`tthis`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A2%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 方法，而 [`tthis(4)`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A2%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 是直接调用 [`tthis`](command:_github.copilot.openSymbolFromReferences?%5B%7B%22%24mid%22%3A1%2C%22fsPath%22%3A%22e%3A%5C%5CBlog%5C%5Csource%5C%5C_posts%5C%5Cjs-this-1.js%22%2C%22_sep%22%3A1%2C%22external%22%3A%22file%3A%2F%2F%2Fe%253A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22path%22%3A%22%2Fe%3A%2FBlog%2Fsource%2F_posts%2Fjs-this-1.js%22%2C%22scheme%22%3A%22file%22%7D%2C%7B%22line%22%3A2%2C%22character%22%3A0%7D%5D "source/_posts/js-this-1.js") 函数，因为没有指定调用对象，所以 `this` 是全局对象。
*/
/*
这是因为JavaScript中的`this`关键字的行为取决于它是如何被调用的。在JavaScript中，`this`关键字在函数内部的值取决于函数是如何被调用的。

在你的代码中，当你直接调用`tthis(4)`时，`this`在`tthis`函数内部指向全局对象，因为`tthis`是在全局作用域中被调用的。所以，`this.a`在`tthis`函数内部的值是全局对象的`a`属性，即3。

然而，当你通过`this.tthis(4)`调用时，`this`在`tthis`函数内部指向的是`Object.prototype`，因为你是通过`Object.prototype`的`tthis`方法来调用的。`Object.prototype`没有`a`属性，所以`this.a`在`tthis`函数内部的值是`undefined`。

这就是为什么全局对象的`tthis`方法中`this.a`输出的是`undefined`，而直接调用`tthis`函数`this`也是全局对象却能输出3的原因。
*/
/*
在JavaScript中，`this`关键字的值是在函数被调用时确定的，而不是在函数被定义时确定的。`this`的值取决于函数的调用上下文（也就是调用函数的对象）。

在你的代码中，`Object.prototype.tthis = tthis;`这行代码将函数`tthis`赋值给了`Object.prototype.tthis`。因此，当你通过`this.tthis(4)`调用函数时，`this`在`tthis`函数内部指向的是`Object.prototype`，因为你是通过`Object.prototype`的`tthis`方法来调用的。

如果你直接调用`tthis(4)`，那么`this`在`tthis`函数内部将指向全局对象，因为`tthis`是在全局作用域中被调用的。

这就是为什么通过`Object.prototype`调用`tthis`方法时，`this`指向的是`Object.prototype`而不是全局对象的原因。
*/

//为了验证copilot的说法，我做一个继承
let person = {
    sex: 0,
}
let student = {
    id: "z007",
    brk: function () {
        console.log("brk ", this.sex);
    }
}
student.prototype = person;
student.brk();

let arrow = (a, b) => {
    console.log(this);
    console.log(a + b);
}
let arrow2 = function (a,b) {
    let ar =  (a, b) => {
        console.log(this);
        console.log(a + b);
    }
    return ar(a, b);
}
let obj = {
    qq: "123",
    arrow:arrow2, 
}
let obj2 = {
    qq: "23",
    arrow:arrow2, 
}
obj2.arrow(1, 2);
let obj3 = {
    arrow:()=>console.log(this),
}
obj3.arrow();

function test() {
    this.a = 1;
}
let tt = new test();
test.prototype.b = 2;
console.log(tt.__proto__);]]></content>
  </entry>
  <entry>
    <title>js-rushing-for-honor</title>
    <url>/2024/05/17/js-rushing-for-honor/</url>
    <content><![CDATA[<h1 id="要准备的"><a href="#要准备的" class="headerlink" title="要准备的"></a>要准备的</h1><ul>
<li>[ D ] 闭包  词法（lexical）一词指的是，词法作用域根据源代码中声明变量的位置来确定该变量在何处可用。嵌套函数可访问声明于它们外部作用域的变量。</li>
<li>[ D ] 作用域 执行上下文 全局作用域 函数作用域 块作用域let&#x2F;const </li>
<li>[ D ] 原型链 链表   构造函数.prototype 实例.<strong>proto</strong>  都是指向原型</li>
<li>[ D ] 继承 class extends super（父亲构造函数）原型链</li>
<li>[ D ] this </li>
<li><input disabled="" type="checkbox"> 事件循环 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop</a></li>
<li><input disabled="" type="checkbox"> 对象处理函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/assign</a></li>
<li><input disabled="" type="checkbox"> Promise</li>
<li><input disabled="" type="checkbox"> async&#x2F;await</li>
<li><input disabled="" type="checkbox"> 事件委托 委托给父容器 event.target event.currentTarget</li>
<li><input disabled="" type="checkbox"> 事件冒泡 事件从最深的节点开始，然后逐步向上传播到较高的节点</li>
<li><input disabled="" type="checkbox"> 事件捕获 顺序相反</li>
<li><input disabled="" type="checkbox"> 事件队列 事件循环 jsv9000.app 记得挂梯子<br><strong>花旗杯项目</strong></li>
<li><input disabled="" type="checkbox"> 项目结构 <strong>模块化</strong> 历史上 cmd&#x2F;amd啊 现在 ES Modules</li>
<li><input disabled="" type="checkbox"> 项目初始化</li>
<li><input disabled="" type="checkbox"> 项目配置 webpack vite 区别 vite热更新更快，因为只对该模块进行重新编译，然后进行替换。冷启动也快，因为vite是基于es6的模块化，所以不需要编译整个项目，按需编译。</li>
<li><input disabled="" type="checkbox"> 安全 路由 登陆怎么做 token怎么传</li>
<li><input disabled="" type="checkbox"> 路由鉴权 有些页面需要登陆才能访问，有些页面需要管理员权限才能访问 </li>
<li><input disabled="" type="checkbox"> 性能优化 <a href="https://fe.ecool.fun/topic/a5032eb9-6a53-4792-852f-3f9417631c47?orderBy=updateTime&order=desc&tagId=14">https://fe.ecool.fun/topic/a5032eb9-6a53-4792-852f-3f9417631c47?orderBy=updateTime&amp;order=desc&amp;tagId=14</a> ES6编译时加载大部分，除了加一个动态加载模块import().then 在开发阶段就可以做导入和导出模块相关的代码检查。结合 Webpack、Babel 等工具可以在打包阶段移除上下文中未引用的代码（dead-code），这种技术被称作“tree shaking”，可以极大的减小代码体积、缩短程序运行时间、提升程序性能。 适当导入需要的UI模块，静态资源本地缓存(依赖做强缓存,css等做304协商缓存)，渲染角度讲，减少重排重绘。 <a href="https://zhuanlan.zhihu.com/p/88639980">https://zhuanlan.zhihu.com/p/88639980</a> cdn 路由动态加载 组件动态加载</li>
<li><input disabled="" type="checkbox"> 移动端适配&#x2F;响应式设计<br><strong>css</strong></li>
<li><input disabled="" type="checkbox"> 布局练手</li>
<li><input disabled="" type="checkbox"> 属性复习 grid&#x2F;flex<br><strong>react</strong></li>
<li><input disabled="" type="checkbox"> 生命周期 <a href="https://fe.ecool.fun/topic/460a9714-1001-4beb-b12a-be8fec732879?orderBy=updateTime&order=desc&titleKey=hook">https://fe.ecool.fun/topic/460a9714-1001-4beb-b12a-be8fec732879?orderBy=updateTime&amp;order=desc&amp;titleKey=hook</a></li>
<li><input disabled="" type="checkbox"> hooks useEffect 传了哪些参数，返回值是什么 每次渲染执行第一个回调函数，return一个函数，每次组件卸载执行</li>
<li><input disabled="" type="checkbox"> hooks useState 状态管理</li>
<li><input disabled="" type="checkbox"> hooks useContext 传值，很远的地方也可以传值</li>
<li><input disabled="" type="checkbox"> hooks useReducer 和useState差不多，只是移到了外面，方便管理</li>
<li><input disabled="" type="checkbox"> hooks useRef 不用于展示的值，不会在渲染后丢失<br><strong>vue</strong></li>
<li><input disabled="" type="checkbox"> 生命周期</li>
<li><input disabled="" type="checkbox"> 双向绑定</li>
<li><input disabled="" type="checkbox"> vue-router  history模式和hash模式 动态加载路由，可以在路由跳转时加载对应的组件，而不是一次性加载所有组件</li>
<li><input disabled="" type="checkbox"> vuex 现在是pinia 当然也可以手动 store.js 里面 用响应式api 像reactive(),ref(),然后导出,reactive只能对象，ref可以是基本类型，一般用ref</li>
<li><input disabled="" type="checkbox"> 组合式API<br><strong>网络</strong><br><img src="/image.png" alt="alt text"></li>
<li><input disabled="" type="checkbox"> http&#x2F;https <a href="https://zhuanlan.zhihu.com/p/450128753">https://zhuanlan.zhihu.com/p/450128753</a> <strong>100</strong>Information <strong>200</strong>Success <strong>300</strong>Redirection <strong>400</strong>ClientError <strong>500</strong>ServerError</li>
<li><input disabled="" type="checkbox"> POST<br>预检请求</li>
<li><input disabled="" type="checkbox"> http2</li>
<li><input disabled="" type="checkbox"> get&#x2F;post 幂等 url 实体(body) 传参 缓存</li>
<li><input disabled="" type="checkbox"> 跨域</li>
<li><input disabled="" type="checkbox"> 重定向<br>重定向就是，在网页上设置一个约束条件，条件满足，就自动转入到其它网页、网址。比如登录后跳转。如何实现呢<br>window.location &#x3D; “<a href="https://example.com/">https://example.com/</a>“;<br>react umijs login history推入重定向链接 路由权限就用 model 维护全局状态access:canAdmin函数去计算权限是不是够<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">location</span>.<span class="property">href</span> = <span class="string">&#x27;http://www.baidu.com&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
<li><input disabled="" type="checkbox"> 缓存</li>
<li><input disabled="" type="checkbox"> cookie</li>
<li><input disabled="" type="checkbox"> session</li>
<li><input disabled="" type="checkbox"> token</li>
<li><input disabled="" type="checkbox"> jwt</li>
</ul>
<h2 id="问题们"><a href="#问题们" class="headerlink" title="问题们"></a>问题们</h2><ul>
<li><p><input disabled="" type="checkbox"> 
vue和react的区别，你觉得哪个更好<br>vue是响应式的 数据绑定 靠watcher 响应式更新vDOM react是函数式的 数据流 数据不可变 JSX</p>
</li>
<li><p><input disabled="" type="checkbox"> 
websocket和http的区别<br>websocket是全双工的，http是半双工的（这个说法有问题 全双工这类说法是在物理链路层的），websocket是长连接，http是短连接 http1.1开始也有长的 http无状态 指的是一个用户连续发两个你都不知道是一个发的 websocket有状态 游戏 聊天 这种连续的数据流</p>
</li>
<li><p><input disabled="" type="checkbox"> 
ES6的新特性</p>
</li>
<li><p><input disabled="" type="checkbox"> 
你对闭包的理解</p>
</li>
<li><p><input disabled="" type="checkbox"> 
你对作用域的理解</p>
</li>
<li><p><input disabled="" type="checkbox"> 
你对原型链的理解</p>
</li>
<li><p><input disabled="" type="checkbox"> 
前端工程化 webpack vite<br><a href="https://fe.ecool.fun/topic/1db9414f-b160-4cf6-9a3c-32d8b7acb4ff">https://fe.ecool.fun/topic/1db9414f-b160-4cf6-9a3c-32d8b7acb4ff</a><br>模块化打包的工具  依赖导入导出 TreeShaking依赖于ES Module的静态语法分析（不执行任何的代码，可以明确知道模块的依赖关系）<br>vite启动和热更新很快,按需加载,利用浏览器原生的ES Module编译能力，省略费时的编译环节，直给浏览器开发环境源码，dev server只提供轻量服务<br>webpack proxy 前端代理,本质是一个http中间件(Tomcat Redis),起一个同端口的服务，然后转发请求，解决跨域问题</p>
</li>
<li><p><input disabled="" type="checkbox"> 
说一说react循环渲染的过程<br> 每次调用 setState 或 useState 的 setter 函数时，都会触发一次重新渲染请求。批量更新机制,同一个事件循环里面发生的状态更新会合并成一次.<strong>然后生成虚拟DOM</strong>.优先级的话,调度器,用户输入优先响应.<br> react会先生成虚拟DOM，然后对比新旧虚拟DOM，找到差异,生成DOM指令集,然后更新真实DOM.<br>setState是异步的，不会立即更新，会等到事件循环结束后再批量更新</p>
</li>
<li><p><input disabled="" type="checkbox"> 
虚拟DOM<br>就是一个对真实在DOM的抽象，用js对象来描述真实DOM，然后对比两个虚拟DOM的差异，diff，然后更新真实DOM<br><a href="https://fe.ecool.fun/topic/d5acd6cf-38c3-4afb-965d-be79f03cd045">https://fe.ecool.fun/topic/d5acd6cf-38c3-4afb-965d-be79f03cd045</a><br>等等…</p>
</li>
</ul>
<blockquote>
<p>云轴 vue路由守卫如果具体到组件怎么办 路由表 vue3和vue2的区别 vue3有哪些特性 vue3的响应式原理 双向绑定 react的生命周期 自定义hooks 深拷贝怎么实现</p>
</blockquote>
<ul>
<li><p><input disabled="" type="checkbox"> 
类型检查怎么做</p>
</li>
<li><p>Array.isArray() </p>
</li>
<li><p>instanceof (constructor) person instanceof Person&#x2F;Object 只要是原型链上的就是true </p>
</li>
<li><p>typeof 只区分到Object和Function</p>
</li>
<li><p>Object.prototype.toString.call() &#x3D;&#x3D;&#x3D; ‘[object Array]’</p>
</li>
<li><p><input disabled="" type="checkbox"> 
Axios怎么定时请求，超时处理，promise</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//超时处理</span></span><br><span class="line"><span class="attr">timeout</span>: <span class="number">1000</span>,</span><br></pre></td></tr></table></figure></li>
<li><p><input disabled="" type="checkbox"> 
浅拷贝用什么函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = &#123;...obj1&#125;;</span><br><span class="line"><span class="keyword">let</span> obj3 = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj1);</span><br></pre></td></tr></table></figure></li>
<li><p><input disabled="" type="checkbox"> 
深拷贝怎么写  </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj2 = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringfy</span>(obj1));</span><br><span class="line"><span class="keyword">let</span> obj3 = lodash.<span class="title function_">cloneDeep</span>(obj1);</span><br><span class="line"><span class="comment">//手写注意循环引用，用hashmap</span></span><br></pre></td></tr></table></figure>
<p><a href="https://juejin.cn/post/6844904197595332622?searchId=20240520160001A98997C75E69BC6024DA">https://juejin.cn/post/6844904197595332622?searchId=20240520160001A98997C75E69BC6024DA</a></p>
</li>
<li><p><input disabled="" type="checkbox"> 
对象解构</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;John Doe&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: personName, <span class="attr">age</span>: personAge &#125; = person;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personName); <span class="comment">// Output: &#x27;John Doe&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(personAge); <span class="comment">// Output: 30</span></span><br><span class="line"><span class="comment">//数组换[]</span></span><br></pre></td></tr></table></figure></li>
<li><p><input disabled="" type="checkbox"> 
vue，react打包之后的html，有哪些东西</p>
</li>
<li><p><input disabled="" type="checkbox"> 
h5适配<br><a href="https://zhuanlan.zhihu.com/p/425121653">https://zhuanlan.zhihu.com/p/425121653</a></p>
</li>
<li><p><input disabled="" type="checkbox"> 
BOM<br><img src="/image-1.png" alt="alt text"></p>
</li>
<li><p><input disabled="" type="checkbox"> 
this.$nextTick<br> 在修改数据之后立即使用这个方法，获取更新后的 DOM,可以看作和react中的setState 加入列表 等事件循环完 后面延迟执行的回调函数 马上拿到更新后的DOM</p>
</li>
<li><p><input disabled="" type="checkbox"> 
导致重流焊和重绘的原因<br>添加、删除、更新 DOM 节点时将发生重排<br>隐藏 DOM 元素将导致重排和重绘display: none<br>隐藏 DOM 元素将导致唯一的重绘，因为没有布局或位置更改visibility: hidden<br>移动 DOM 节点并设置动画将触发重排和重绘<br>调整窗口大小将触发重排<br>更改字体样式会更改元素的几何形状。这意味着它可能会影响页面上其他元素的位置或大小，这两者都需要浏览器执行重排。 一旦这些布局操作完成，任何损坏的像素都需要重新绘制<br>添加或删除样式表将导致重排&#x2F;重绘<br>操作 DOM 的脚本是一项代价高昂的操作，因为它们每次修改文档或文档的一部分时都会重新计算。正如我们从触发回流焊的许多事情中看到的那样，它每秒可以发生数千次</p>
</li>
</ul>
]]></content>
      <categories>
        <category>note</category>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2024/05/20/js-promise/</url>
    <content><![CDATA[//懂又不懂呀系列01
]]></content>
  </entry>
</search>
